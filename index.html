<html>
<head>
	<script>
		window.onresize = new function () { resize(); }

		//canvas size
		var width = window.innerWidth;
		var height = window.innerHeight;
		//end canvas size

		//program variables
		var canvas;
		var context;

		var geometryProgram;
		var glid_gp_a_position;


		var glid_tri_positionBuffer;
		var glid_vao;
		//end program variables

		//data
		var tri_positions = [
		-1.0, 0.0, 0.0,
		Math.cos(Math.PI * 5/3), Math.sin(Math.PI * 5/3), 0.0,
		Math.cos(Math.PI * 1/3), Math.sin(Math.PI * 1/3), 0.0		
		];
		//end data

		//program shaders
		var vertexShaderSource = 
		"#version 300 es\n" +
		"in vec4 a_position;\n" +

		"void main() {\n" +
		"	gl_Position = a_position;\n" +
		"}"
		;

		var fragmentShaderSource = 
		"#version 300 es\n" +
		"precision mediump float;\n" +

		"out vec4 outColor;\n" +

		"void main() {\n" +
		"	outColor = vec4(1.0, 1.0, 1.0, 1.0);\n" +
		"}"
		;
		//end program shaders

		function init () {
			canvas = document.getElementById('gameCanvas');
			if(!canvas) console.error('ERROR: Failed to get the canvas element.');
			canvas.width = width;
			canvas.height = height;

			context = canvas.getContext('webgl2');
			if(!context) console.error('ERROR: Failed to instantiate a WebGL2 context.');

			resize();

			initGeometryProgram();

			initContext();

			context.useProgram(geometryProgram);

			glid_tri_positionBuffer = initBuffer(context.ARRAY_BUFFER, tri_positions);
			glid_vao = initVao(0, 3);

			draw();
		}

		function initBuffer(bufferType, bufferData) {
			glid_tri_positionBuffer = context.createBuffer();
			if(!glid_tri_positionBuffer)  {
				console.error('ERROR: Failed to instantiate buffer.');
				return null;
			}

			context.bindBuffer(bufferType, glid_tri_positionBuffer);
			context.bufferData(bufferType, new Float32Array(bufferData), context.STATIC_DRAW);
			return glid_tri_positionBuffer;
		}

		function initVao(attribLocation, attribLength) {
			glid_vao = context.createVertexArray();
			if(!glid_vao) {
				console.error('ERROR: Failed to instantiate vertex array object.');
				return null;
			}
			context.bindVertexArray(glid_vao);

			context.enableVertexAttribArray(attribLocation);
			context.vertexAttribPointer(attribLocation, attribLength, context.FLOAT, false, 0, 0);
			return glid_vao
		}

		function initContext() {
			context.cullFace(context.BACK);
			context.frontFace(context.CCW);
			context.enable(context.DEPTH_TEST);
			context.enable(context.CULL_FACE);
			context.depthFunc(context.LEQUAL);
			context.blendFunc(context.SRC_ALPHA, context.ONE_MINUS_SRC_ALPHA);
			context.clearColor(0.0, 0.0, 0.0, 1.0);
		}

		function draw (currentTime) {
			context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);

			context.bindVertexArray(glid_vao);

			context.drawArrays(context.TRIANGLES, 0, 3);

			window.requestAnimationFrame(draw);
		}

		function initGeometryProgram() {
			geometryProgram = createProgram(
				context,
				createShader(context, context.VERTEX_SHADER, vertexShaderSource),
				createShader(context, context.FRAGMENT_SHADER, fragmentShaderSource)
				);

			glid_gp_a_position = context.getAttribLocation(geometryProgram, 'a_position');
		}

		function createShader (gl, type, source) {
			var shader = gl.createShader(type);
			gl.shaderSource(shader, source);
			gl.compileShader(shader);
			var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
			if(success) return shader;
			console.error('ERROR: Failed to compile shader:\n' + source + '\n\n' + gl.getShaderInfoLog(shader));
			gl.deleteShader(shader);
		}

		function createProgram(gl, vertexShader, fragmentShader) {
			var program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);
			var success = gl.getProgramParameter(program, gl.LINK_STATUS);
			if(success) return program;
			console.error('ERROR: Failed to link shader program:\n' + gl.getProgramInfoLog(program));
			gl.deleteProgram(program);
		}

		function resize() {
			if(!canvas || !context) return;
			width = window.innerWidth;
			height = window.innerHeight;

			canvas.width = width - 0;
			canvas.height = height - 0;

			if(context) context.viewport(0,0,width,height);
		}
	</script>
	<style>
		body {
			margin: 0;
		}
	</style>
</head>
<body onload="init()">
	<canvas id="gameCanvas"></canvas>
</body>
</html>