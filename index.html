<html>
<head>
	<script>
		window.onresize = function () { resized = true; }

		//canvas size
		var width = window.innerWidth;
		var height = window.innerHeight;
		//end canvas size

		//program variables
		var canvas;
		var context;

		var geometryProgram;
		var glid_gp_a_position;

		var glid_tri_positionBuffer;
		var glid_boid_offsetBuffer;
		var glid_vao;

		var uniformLocations = [];

		var previousFrameTime = 0.0;
		var keyStates = [];
		//end program variables

		//camera vars
		var FOV = 90.0/180.0 * Math.PI;
		var tanHalfFOV = Math.tan(FOV/2.0);
		var nearZ = 0.001;
		var farZ = 8097.0;
		var projA = (-nearZ-farZ)/(nearZ-farZ);
		var projB = (2.0*farZ*nearZ)/(nearZ-farZ);
		var resized = false;

		var cameraX = 0.0;
		var cameraY = 0.0;
		var cameraZoom = 128.0;
		var targetZoom = 128.0;
		var zoomSpeed = 1.0;
		//end camera vars

		//data
		var tri_positions = [
		1.0, 0.0, 1.0,
		Math.cos(Math.PI * 2/3), Math.sin(Math.PI * 2/3), 0.0,
		Math.cos(Math.PI * 4/3), Math.sin(Math.PI * 4/3), 0.0		
		];

		var num_instances = 100000;
		var boidInfo = new Float32Array(num_instances * 4);
		var boidSpeeds = [];

		var start = [-15.0, -25.0];
		var end = [35.0, 25.0];
		var glr = 1.25;
		var force = 1.0;
		//end data

		//program shaders
		var vertexShaderSource = 
		`#version 300 es
		in vec3 a_position;
		in vec4 a_inst_offsetXY_forwardZW;

		const vec4 eyeColor = vec4(1.0, 1.0, 1.0, 1.0);
		const vec4 bodyColor = vec4(1.0, 0.0, 0.0, 1.0);

		uniform mat4 u_projectionMatrix;
		uniform mat4 u_cameraPositionMatrix;

		smooth out lowp vec4 vColor;

		void main() {
			vColor = mix(bodyColor, eyeColor, a_position.z);

			mat4 instanceTransformMat = mat4(
			a_inst_offsetXY_forwardZW.z, a_inst_offsetXY_forwardZW.w, 0.0, 0.0,
			-a_inst_offsetXY_forwardZW.w, a_inst_offsetXY_forwardZW.z, 0.0, 0.0,
			0.0, 0.0, 1.0, 0.0,
			a_inst_offsetXY_forwardZW.x, a_inst_offsetXY_forwardZW.y, 0.0, 1.0
			);

			gl_Position = u_projectionMatrix * u_cameraPositionMatrix * instanceTransformMat * vec4(a_position.xy, 0.0, 1.0);
		}
		`;

		var fragmentShaderSource = 
		`#version 300 es
		precision mediump float;

		smooth in lowp vec4 vColor;

		out vec4 outColor;

		void main() {
			outColor = vColor;
		}
		`;
		//end program shaders

		function init () {
			canvas = document.getElementById('gameCanvas');
			if(!canvas) console.error('ERROR: Failed to get the canvas element.');
			canvas.width = width;
			canvas.height = height;

			context = canvas.getContext('webgl2');
			if(!context) console.error('ERROR: Failed to instantiate a WebGL2 context.');

			initGeometryProgram();

			initContext();

			context.useProgram(geometryProgram);

			resize();

			for (var i = 0; i < num_instances; i++) {
				var forwardAngle = Math.random() * Math.PI * 2.0;
				boidInfo[i*4] = Math.random() * 50 - 25;
				boidInfo[i*4 + 1] = Math.random() * 50 - 25;
				boidInfo[i*4 + 2] = Math.cos(forwardAngle);
				boidInfo[i*4 + 3] = Math.sin(forwardAngle);
				boidSpeeds[i] = Math.random() * 10;
			}

			initBuffers();
			initVao();

			draw();
		}

		function initBuffers() {
			glid_tri_positionBuffer = context.createBuffer();
			if(!glid_tri_positionBuffer) {
				console.error('ERROR: Failed to instantiate triangle vertex buffer.');
				return null;
			}
			context.bindBuffer(context.ARRAY_BUFFER, glid_tri_positionBuffer);
			context.bufferData(context.ARRAY_BUFFER, new Float32Array(tri_positions), context.STATIC_DRAW);

			glid_boid_offsetBuffer = context.createBuffer();
			if(!glid_boid_offsetBuffer) {
				console.error('ERROR: Failed to instantiate boid offset buffer.');
				return null;
			}
			context.bindBuffer(context.ARRAY_BUFFER, glid_boid_offsetBuffer);
			context.bufferData(context.ARRAY_BUFFER, boidInfo, context.DYNAMIC_DRAW);
		}

		function initVao() {
			glid_vao = context.createVertexArray();
			if(!glid_vao) {
				console.error('ERROR: Failed to instantiate vertex array object.');
				return null;
			}
			context.bindVertexArray(glid_vao);

			//vertex and color attribute
			context.bindBuffer(context.ARRAY_BUFFER, glid_tri_positionBuffer);
			context.enableVertexAttribArray(0);
			context.vertexAttribPointer(0, 3, context.FLOAT, false, 0, 0);

			//offset attribute
			context.bindBuffer(context.ARRAY_BUFFER, glid_boid_offsetBuffer);
			context.enableVertexAttribArray(1);
			context.vertexAttribPointer(1, 4, context.FLOAT, false, 16, 0);
			context.vertexAttribDivisor(1, 1);
		}

		function initContext() {
			context.cullFace(context.BACK);
			context.frontFace(context.CCW);
			context.enable(context.DEPTH_TEST);
			context.enable(context.CULL_FACE);
			context.depthFunc(context.LEQUAL);
			context.blendFunc(context.SRC_ALPHA, context.ONE_MINUS_SRC_ALPHA);
			context.clearColor(0.0, 0.0, 0.0, 1.0);
		}

		function draw (currentTime) {
			var deltaTime = (currentTime - previousFrameTime) / 1000;
			handleInput(deltaTime);
			handleZoom(deltaTime);
			if(resized) { resize(); }

			updateBoids(deltaTime);

			context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);

			context.bindVertexArray(glid_vao);

			context.uniformMatrix4fv(
				uniformLocations['u_cameraPositionMatrix'], 
				false,
				new Float32Array([
					1.0, 0.0, 0.0, 0.0,
					0.0, 1.0, 0.0, 0.0,
					0.0, 0.0, 1.0, 0.0,
					cameraX, cameraY, cameraZoom, 1.0
					])
				);

			//context.drawArrays(context.TRIANGLES, 0, 3);
			context.drawArraysInstanced(context.TRIANGLES, 0, 3, boidInfo.length/4);

			previousFrameTime = currentTime;
			window.requestAnimationFrame(draw);
		}

		function updateBoids(deltaTime) {
			if(isNaN(deltaTime)) return;

			var er = glr;

			for(var i = 0; i < boidInfo.length/4; i++) {
				//translate from speed and direction to velocity
				var velX = boidInfo[4*i + 2] * boidSpeeds[i];
				var velY = boidInfo[4*i + 3] * boidSpeeds[i];

				//update positions for velocity
				boidInfo[4*i] += velX * deltaTime;
				boidInfo[4*i + 1] += velY * deltaTime;

				var boid_p = [boidInfo[4*i], boidInfo[4*i + 1]];
				var b2s_i = p2pDistance(boid_p[0], boid_p[1], start[0], start[1]);
				var b2e_i = p2pDistance(boid_p[0], boid_p[1], end[0], end[1]);
				var c_p = [(start[0] + end[0]) / 2.0, (start[1] + end[1]) / 2.0];
				var b2c_i = p2pDistance(boid_p[0], boid_p[1], c_p[0], c_p[0])
				var gll_i = p2pDistance(start[0], start[1], end[0], end[1]);
				var accel_v = [0.0, 0.0];
				var b2c_v = [(c_p[0] - boid_p[0]) / b2c_i, (c_p[1] - boid_p[1]) / b2c_i];		

				if(b2s_i + b2e_i < gll_i * er) {
					//guide and arrest motion lateral to the guideline
					var glv_v = [(end[0] - start[0]) / gll_i, (end[1] - start[1]) / gll_i];
					var arrestingForce = 
						arrestLateralMotionForce(glv_v[0], glv_v[1], boidInfo[4*i + 2], boidInfo[4*i + 3]);
					accel_v[0] += (glv_v[0] + arrestingForce[0]) * (force);
					accel_v[1] += (glv_v[1] + arrestingForce[1]) * (force);
				}
				if(b2s_i + b2e_i > gll_i * er && b2c_i < 2.0 * gll_i) {
					//pull towards start
					var b2s_v = [(start[0] - boid_p[0]) / b2s_i, (start[1] - boid_p[1]) / b2s_i];
					accel_v[0] += b2s_v[0] * force * 2;
					accel_v[1] += b2s_v[1] * force * 2;
					
					//if closer to end push away from center
					if(b2e_i < b2s_i) {
						accel_v[0] -= b2c_v[0] * force * 2;
						accel_v[1] -= b2c_v[1] * force * 2;
					} 
					//if closer to end add drag
					else {

					}
				}
				if(b2c_i > 2.0 * gll_i) {
					//pull towards nearest guideline
					accel_v[0] += b2c_v[0] * force;
					accel_v[1] += b2c_v[1] * force;
				}

				//update velocity components and positions for acceleration
				velX += accel_v[0] * deltaTime;
				velY += accel_v[1] * deltaTime;

				boidInfo[4*i] += accel_v[0] * deltaTime / 2.0;
				boidInfo[4*i + 1] += accel_v[1] * deltaTime / 2.0;

				//split velocity to speed and direction again
				boidSpeeds[i] = Math.sqrt(velX * velX + velY * velY);
				boidInfo[4*i + 2] = velX / boidSpeeds[i];
				boidInfo[4*i + 3] = velY / boidSpeeds[i];

				//if(i == 0) console.log('(' + boidInfo[4*i] + ', ' + boidInfo[4*i + 1] + ')');
			}
			context.bindBuffer(context.ARRAY_BUFFER, glid_boid_offsetBuffer);
			context.bufferSubData(context.ARRAY_BUFFER, 0, boidInfo);
		}

		function arrestLateralMotionForce(v_tx, v_ty, v_vx, v_vy, aav) {
			// calculate antilateral direction
			var dot = dot2f(v_vx, v_vy, v_tx, v_ty);
			var reflectionX = v_tx * dot - v_vx;
			var reflectionY = v_ty * dot - v_vy;

			// arrest antitarget vector
			if(dot < 0 && aav) {
				reflectionX += v_tx * (-dot);
				reflectionY += v_ty * (-dot);
			}

			return [reflectionX, reflectionY];
		}

		function p2pDistance (p1x, p1y, p2x, p2y) {
			return Math.sqrt(((p1x-p2x)*(p1x-p2x))+
					((p1y-p2y)*(p1y-p2y)));
		}

		function dot2f (p1x, p1y, p2x, p2y) {
			return (p1x * p2x + p1y * p2y);
		}

		function initGeometryProgram() {
			geometryProgram = createProgram(
				context,
				createShader(context, context.VERTEX_SHADER, vertexShaderSource),
				createShader(context, context.FRAGMENT_SHADER, fragmentShaderSource)
				);
			if(!geometryProgram) return;

			glid_gp_a_position = context.getAttribLocation(geometryProgram, 'a_position');

			uniformLocations['u_projectionMatrix'] = 
				context.getUniformLocation(geometryProgram, 'u_projectionMatrix');
			if(!uniformLocations['u_projectionMatrix']) {
				console.error('ERROR: The location of uniform: u_projectionMatrix was null.');
				return;
			}

			uniformLocations['u_cameraPositionMatrix'] = 
				context.getUniformLocation(geometryProgram, 'u_cameraPositionMatrix');
			if(!uniformLocations['u_cameraPositionMatrix']) {
				console.error('ERROR: The location of uniform: u_cameraPositionMatrix was null.');
				return;
			}
		}

		function createShader (gl, type, source) {
			var shader = gl.createShader(type);
			gl.shaderSource(shader, source);
			gl.compileShader(shader);
			var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
			if(success) return shader;
			console.error('ERROR: Failed to compile shader:\n' + source + '\n\n' + gl.getShaderInfoLog(shader));
			gl.deleteShader(shader);
		}

		function createProgram(gl, vertexShader, fragmentShader) {
			var program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);
			var success = gl.getProgramParameter(program, gl.LINK_STATUS);
			if(success) return program;
			console.error('ERROR: Failed to link shader program:\n' + gl.getProgramInfoLog(program));
			gl.deleteProgram(program);
		}

		function resize() {
			if(!canvas || !context) return;
			resized = false;
			width = window.innerWidth;
			height = window.innerHeight;

			canvas.width = width - 0;
			canvas.height = height - 0;

			if(context) context.viewport(0,0,width,height);

			if(geometryProgram) context.uniformMatrix4fv(
				uniformLocations['u_projectionMatrix'], 
				false,
				new Float32Array([
					1.0/(width/height * tanHalfFOV), 0.0, 0.0, 0.0,
					0.0, 1.0/tanHalfFOV, 0.0, 0.0,
					0.0, 0.0, projA, 1.0,
					0.0, 0.0, projB, 0.0
					])
				);
		}

		function handleZoom(deltaTime) {
			if(cameraZoom < targetZoom) {
				cameraZoom *= (1.0 + zoomSpeed * deltaTime);
				if(cameraZoom > targetZoom) cameraZoom = targetZoom;
			}
			if(cameraZoom > targetZoom) {
				cameraZoom *= (1.0 - zoomSpeed * deltaTime);
				if(cameraZoom < targetZoom) cameraZoom = targetZoom;	
			}
		}

		function handlekeydown(event) {
			keyStates[event.keyCode] = true;
		}

		function handlekeyup(event) {
			keyStates[event.keyCode] = false;
		}

		function handlescroll(event) {
			if(event.deltaY > 0)
			{
				targetZoom *= 2.0;
				if(targetZoom > 8096.0) targetZoom = 8096.0;
			} else if (event.deltaY < 0) {
				targetZoom /= 2.0;
				if(targetZoom < 1.0) targetZoom = 1.0;	
			}
			//console.log(cameraZoom);			
		}

/* KEYCODES
			W = 87		E = 69	|	U = 85		I = 73		O = 79	|	[ = 219		] = 221		
A = 65		S = 83		D = 68	|	J = 74		K = 75		L = 76	|
						C = 67	|	M = 77
*/
		function handleInput(deltaTime) {
			if(keyStates[87]) cameraY -= deltaTime * cameraZoom;
			if(keyStates[83]) cameraY += deltaTime * cameraZoom;

			if(keyStates[65]) cameraX += deltaTime * cameraZoom;
			if(keyStates[68]) cameraX -= deltaTime * cameraZoom;
		}
	</script>
	<style>
		body {
			margin: 0;
		}
	</style>
</head>
<body onload="init()" onkeydown="handlekeydown(event)" onkeyup="handlekeyup(event)" onmousewheel="handlescroll(event)">
	<canvas id="gameCanvas"></canvas>
</body>
</html>